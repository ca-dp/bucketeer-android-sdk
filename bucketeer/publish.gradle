apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'

def properties = new Properties()
properties.load(rootProject.file('local.properties').newDataInputStream())
def VERSION = properties.getProperty("sdk.version") ?: System.getenv("SDK_VERSION")

def GROUP_ID = project.findProperty("publish.groupId")
def ARTIFACT_ID = project.findProperty("publish.artifactId")
def VCS_URL = project.findProperty("publish.vcsUrl")

def pomConfig = {
    licenses {
        license {
            name "The Apache Software License, Version 2.0"
            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
            distribution "repo"
        }
    }
    scm {
       url VCS_URL
    }
}

// https://stackoverflow.com/questions/26874498/publish-an-android-library-to-maven-with-aar-and-source-jar
task androidSourcesJar(type: Jar) {
    archiveClassifier.set('sources')
    from android.sourceSets.main.java.srcDirs
}

// https://github.com/bintray/gradle-bintray-plugin/blob/67718c3a65b64dbfe7534a82a178da2c57153a5d/README.md
bintray {
  user = properties.getProperty("bintray.user") ?: System.getenv("BINTRAY_USER")
  key = properties.getProperty("bintray.api_key") ?: System.getenv("BINTRAY_API_KEY")
  publish = true
  pkg {
    repo = 'maven'
    name = GROUP_ID + '.' + ARTIFACT_ID
    licenses = ['Apache-2.0']
    vcsUrl = VCS_URL
    version {
      name = VERSION
      released  = new Date()
      gpg {
        sign = true
      }
    }
  }
  publications = ['MyPublication'] 
}

publishing {
  publications {
    MyPublication(MavenPublication) {
      artifact source: file("${project.buildDir}/outputs/aar/${project.name}-release.aar")
      artifact androidSourcesJar

      groupId = GROUP_ID
      artifactId = ARTIFACT_ID
      version = VERSION

      pom.withXml {
        def root = asNode()
        root.children().last() + pomConfig

        // dependencies
        final dependenciesNode = root.appendNode('dependencies')

        ext.addDependency = { Dependency dep, String scope ->
          if (dep.group == null || dep.version == null || dep.name == null || dep.name == "unspecified")
            return // ignore invalid dependencies

          final dependencyNode = dependenciesNode.appendNode('dependency')
          dependencyNode.appendNode('groupId', dep.group)
          dependencyNode.appendNode('artifactId', dep.name)
          dependencyNode.appendNode('version', dep.version)
          dependencyNode.appendNode('scope', scope)

          if (!dep.transitive) {
            // If this dependency is transitive, we should force exclude all its dependencies them from the POM
            final exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
            exclusionNode.appendNode('groupId', '*')
            exclusionNode.appendNode('artifactId', '*')
          } else if (!dep.properties.excludeRules.empty) {
            // Otherwise add specified exclude rules
            final exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
            dep.properties.excludeRules.each { ExcludeRule rule ->
              exclusionNode.appendNode('groupId', rule.group ?: '*')
              exclusionNode.appendNode('artifactId', rule.module ?: '*')
            }
          }
        }

        // List all "compile" dependencies (for old Gradle)
        configurations.compile.getAllDependencies().each { dep -> addDependency(dep, "compile") }
        // List all "api" dependencies (for new Gradle) as "compile" dependencies
        configurations.api.getAllDependencies().each { dep -> addDependency(dep, "compile") }
        // List all "implementation" dependencies (for new Gradle) as "runtime" dependencies
        configurations.implementation.getAllDependencies().each { dep -> addDependency(dep, "runtime") }
      }
    }
  }
}
